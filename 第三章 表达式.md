## 第三章 表达式

### 词法

####源文件
  Python2  解释器以ASCII 为默认编码, 如果源码里出现Unicode 字符就会导致无法正确解析, 解决办法是在源文件头部,增加 # - * - coding: utf-8 - * -  来声明.   python3 已将默认编码改为utf-8  无须特别申明

* 执行
  在入口文件头部,添加shebang信息, 可以指定系统程序载入器使用指定解释器执行, 同时执行是别忘记给文件添加可执行程序
  如:

`! /usr/bin/env python`     

` chmod a+x main.py`  添加可执行权限

* 命令行

  命令行参数分解释器和程序两种 分别以 sys.flags, sys.argv 读取

  ` import sys`

  `print(sys,flags,optimize)`

  `print(sys.argv)`

 `   python3  -oo main.py 1 2 "hello, world"`

* 退出
  sys.exit   异常捕获,

  ```try:
  try:	
  	sys.exit()
  
  except Exception as e:
  
  	print(e)
  
  finally:
  
  	print("*****")```
  
  ```

####代码

  1. 缩进 一般遵循pep8规范

  2. 注释  # 号  注释   三引号注释

### 赋值

  赋值操作为名字和目标对象建立关联

  ```  a= b =c = 1234
  # 同时为多个名字建立关联
  >>>a= b =c = 1234
  >>>a is b is c
  True
  
  # 仅以逗号分隔的多个右值被视作元祖的初始化值
  >>> x = 1,2,3,"avb",[1,2,3]
  >>> x 
  (1,2,3,"avb",[1,2,3])
  ```

####增量赋值

  增量赋值,顾名思义 就是直接修改原对象内容,实现增加效果.

  1 . 既然是增量需确保目标已存在

  2 , 对比可变列表和不可变元祖增量赋值结果 (列表直接修改原内容, 而元祖是新建对象)

  ```
  >>> a = b = []
  >>> a += [1 + 2]
  >>> a is b 
  True              # 依然指向原对象
  
  
  >>> c = d = ()
  >>> c +-= (1,2)
  >>> c is d
  False           # 新对象
  ```

#### 序列解包

  序列解包展开所有元素, 继而分别于多个名字关联

  ```
  >>> a,b,c = [1,2,3]
  >>> a,b,c
  1,2,3
  
  >>> a,b,c = "xyz"
  >>> a,b,c
  'x','y','z'
  
  >>> a,b,c = range(3)
  >>> a,b,c
  0,1,2
  
  
  >>>a,b = [1,2],(3,4)    # 右值表达式构建院子对象([1,2],(3,4))
  >>>a
  [1,2]
  >>> b
  (3,4)
  
  
  a,b = b,a    # 解包操作可以用来交换变量, 
  
  >>> a,((b,c),(d,e))  = 1,[(10,20),"ab"]     # 支持深度的嵌套展开
  >>> a,b,c,d,e
  1,10,20,'a','b'
  ```

* 星号收集

  当序列元素与名字不等时, 解析出错. 在名字前面添加星号,表示收纳所有剩余元素

  ```
  >>>a, b = 1,2,3
  VlaueError:.......
  >>> a,*b,c = range(5)   # 名字前面添加星号, 表示收纳所有剩余元素
  >>> a,b,c
  0,[1,2,3],4
  
  >>> a,b,*c = range(5)
  >>> a,b,c
  0,1,[2,3,4]
  
  >>>a, *b,c = 1,2       # 名字多于元素也能处理
  >>> a,b,c
  1,[],2
  
  # Tips:  解包操作优先保障对非收集名字的赋值, 所以元素不能少于非收集名字的数目,另外星号也只能有一个,否则无法界定边界. 星号收集不能单独出现,要么与其他名字一起,要么放入列表或元祖内
  >>> *a = 1,2
  SyntaxError:....
  >>>[*a] = 1,2
  >>> a 
  [1,2]
  
  # 序列解包和星号收集还用于控制流表达式
  >>> fora, *b in ['abc',[1,2,3]]:
  		print(a,b)
  	a  ['b','c']
  	1 [2,3]
  
  ```

* 星号展开

  星号可用来展开可迭代对象

  ```
  >>> a = [1,2]
  >>> b = 'ab'
  c = range(10,13)
  >>> [*a,*b,*c]
  [1,2,'a','b',10,11,12]
  
  >>> d = {'a':1,'b':2}    # 对于字典, 单星号展开主键,双星号展开键值
  >>> [*d]
  ['a','b']
  >>> {'c':3,**d}
  {'c':3,'a':1,'b':2}
  
  
  # 同样可用于函数调用，将单个对象分解成多个实参
  def test(a,b,c):
  	print(locals())
  test(*rang(3))
  {'c':2,'b':1,'a':0}
  ```

####   作用域

作为隐式规则,赋值操作默认总是针对当前名字空间  如果需要对外部变量赋值,需显示申明变量位置, 关键字global 指向全局名字空间,nonlocal 为外层嵌套函数. 不同于global 运行期间行为,nonlocal 要求在编译期间绑定,所以目标变量需提前存在

```
>>> x = 10 
>>> def test():
		print(x)
		x = x + 10
>>> test()

UnboundLocalError:local variable 'x' referenced before assignment



>>> g = 1
>>> def outer():
		e = 2
		def  inner():
			global g   # 声明全局变量
			nonlocal e   # 声明外层嵌套函数变量
			g = 10
			e = 20
			
		inner()
		return e
			
>>> outer()
20

>>>g
10
			
			
			
```

###  运算符

#### 链式比较

```
>>> a,b = 2,3
>>> a> 0 and  b>a and b<5
True

>>> 0 < a <b < 5   # 链式比较可读性好,易于维护
True

```

#### 切片

切片用于表达序列片段或整体,具体行为与其在语句中的位置有关

```
>>> x = [1,2,3,4,5,6,7,8]
>>> s = x[2:5]
>>> s 
[3,4,5]

>>> x.insert(3,100)    # 对原列表的修改,不影响切片
>>> x
[1,2,3,100,4,5,6,7,8]

>>> s 
[3,4,5]
```



* 删除

  用切片指定要删除的序列范围

  ```
  >>> x = [0,1,2,3,4,5,6,7]
  >>> x[3:7]
  [3,4,5,6]
  >>> del x[3:7]
  >>> x 
  [0,1,2,7]
  
  
  ```

* 赋值

  以切片方式进行序列局部赋值, 相当于先删除,后插入

  ```
  >>> x = [0,1,2,3,4,5,6]
  >>> x[1:4] = [10,20]
  >>> x
  [0,10,20,4,5,6]
  
  # 如果设定步进,则删除和插入的元素数量必须相等
  >>> x = [0,1,2,3,4,5,6,7,8,9]
  >>> x[::2]
  [0,2,4,6,8]
  >>>x[::2] = [100,200,400,600,800]
  >>> x
  [100,1,200,3,400,5,600,7,800,9]
  
  
  ```


* 逻辑运算

  逻辑运算用于判断多条件的布尔结果  and  or   not

* 条件表达式

  常见的逻辑运算时天剑表达式,类似功能在其他语言被称作三元运算符

  ``` 
  >>> 'T' if 2 >1 else 'F'
  'T'
  >>> 'T' if 2 <1 else 'F'
  'F'
  
  
  # 等同于
  >>> 2 >1 and 'T' or 'F'
  'T'
  
  >>> 2 < 1 and 'T' or 'F'
  'F'
  
  # 建议使用表达式
  ```


### 控制流

####选择

```
def test(x):
	if x > 0:
		print("++++")
	elif x < 0 :
		print("-----")
	else:
		print("=")
```

####循环

循环语句分为 while  for 两种.前者用于执行逻辑循环, 后者偏向于对象内容迭代,

```
>>> while n > 0:
		print(n)
		
>>> for i  in  range(3):
		print(i)		
		
```


* 迭代

  遍历可迭代对象(iterate) 时, 可进一步执行序列解包, 次序是先取迭代元素, 随后对该元素做解包操作.

  ```
  >>> for a,b in [(1,2),(3,5)]:
  		print(a,b)
  1 2
  3 5
  
  >>> for  a ,b in [1,2]:
  		print(a,b)
  		
  TypeError:'int object is not  iterable
  
  # 如要实现传统的for 循环 可借助enumerate 类型, 它为迭代元素添加自增序号,如此可后去操作索引值
  >>> for i ,x in enumerate([100,200,300]):
  		print(i,x)
  0 100
  1 200
  2 300
  
  # 如迭代对象是以函数返回, 那么该函数仅调用一次
  >>> def data():
  		print("data")
  		return range(3)
  		
  >>> for i in data():
  		print(i)
  		
  data
  0
  1
  2
  ```

* 可选分支

  与其他语言不通, Python循环语句可自选else 分支,在循环正常结束时执行

  (正常结束值得是循环没有被break, return 中断,另外continue 是允许的他不是中断)

  ```
  >>> n = 3
  >>> while n > 0:
  		n -= 1
  	else:
  		print('over')
  		
  over
  
  
  >>> n = 3
  >>> while n > 0:
  		print('break')
  		break     # break导致else 不会执行
  	else:
  		print('over')
  break
  ```


* 临时变量

  循环语句没有单独的名字空间, 器内部临时变量直接影响所在 的上线文

  ```
  def test():
  	while True:
  		x = 100 
  		bresk
  		
  	for i in range(10,20):
  		pass
  	print(locals())   # x, i 实际使用的是test.locals名字空间
  	print(x,i)
  	
  test()
  ['I':19,'x':100]
  100 19
  ```


* 跳转

  结束循环, 设定跳出循环条件
  
### 推导式

推导式由输出表达式, 数据源迭代,过滤表达式(可选) 组成, 常见列表推导式, 字典推导式

```
>>> [x for x in range(10) if x%2 ==0]   # 列表
[0,2,4,6,8]

>>>{k:v,for k,v in zip('abc',range(10,13))}   # 字典
{'a':10,'b':11,'c':12}

>>>{x for x in 'abc'}    # 集合
{'a','b','c'}
```

* 嵌套

  ```
  >>> l =[]
  >>> for x in 'abc':
  		if x ! = 'c':
  			for y in  range(3):
  				if y!= 0:
  					l.append(f"{x}{y}")
  >>> l
  [a1,a2,b1,b2]
  
  
  
  >>> [f"{x}{y}" for x in 'abc' if x !='c'    
  				for y in range(3) if y !=0]    # 推到式允许有多个for子句
  				
  [a1,a2,b1,b2]
  ```


* 临时变量

  和普通循环语句不通, 推导式历史变量不影响上下文名字空间

  ```
  def test():
  	a = 'abc'
  	data = {a:b for a,b in zip{'xyz',range(10,13))}    # a,b 不会影响test.locals
  	print(locals())
  	
  test()
  {'data':{'x':10,'y':11,'z':12},'a':'abc}
  ```




* 生成器

  在推导式语法中使用小括号, 结果并非创建元祖, 而是创建生成器对象, 我们称之为生成器表达式

  ```
  >>> (x for x in range(3))
  <generator object <genexpr> at 0x10.....>
  ```
